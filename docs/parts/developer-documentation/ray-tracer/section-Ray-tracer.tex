\section{Online renderelő}
\rhead{Online renderelő}

Az épületek bemutatásának elősegítésének érdekében szerettünk volna egy valósághű képalkotó programot létrehozni, amely beépül a honlapba és a szerkesztőbe is. Erre a célra egy hálózaton elosztott Path Tracer-t írtunk a Rust nevű programozásnyelvben.

\subsection{Raytracer}
Az elmúlt pár évben kifejezetten felkapott lett a \emph{Raytracing} kifejezés. Ezt a Nvidia RTX videókártyáinak megjelenése segítette elő, hiszen ez az első olyan eszköz, amely képes ezt a folyamatot valós-idejűleg megcsinálni. 

A raytracing egy módszer három dimenziós képek létrehozására. Egy másik gyakran használt módszer a raszterizálás, amit általában a játékok és más valósidejű szoftverek (így a mi szerkesztőnk) használnak, mert gyorsabb, de nem olyan sokoldalú, mint a raytracing.

\subsubsection{A módszer leírása}
A raytracing lényege, hogy a kamera képének minden egyes pixeléből egy-egy sugarat "lövünk" ki és megnézzük, hova landol. Landolás után a sugárhoz tartozó pixelt a landolás helye és az ott lévő felület szerint beszínezzük.

E szerint három fő komponense van egy ilyen rendszernek: egy kamera, egy módszer a sugarak landolási helyének eldöntéséhez és egy módszer a pixelek beszínezésére. A raytracerek sokoldalúságát az adja, hogy sokféle komponens létezik amely ezeket a feladatokat felveheti. Teljesen árnyékmentes, csak gömbökkel foglalkozó lyukkamerát használó megoldásoktól kezdve egészen a valósággal összehasonlíthatatlan képeket generáló megoldásokig mindenre képes a megfelelő komponensekkel.

\subsubsection{Gyorsító struktúrák}

A fent említett három komponens közül a a sugár landolásának megkeresése jár a legnagyobb költséggel, hiszen ezt pixelenként kell megnézni, akár többször is.

Az Archytex-ben háromszögekből álló modellekkel dolgozunk. Ha a gép meg szeretné tudni, hogy egy sugár hol találkozik a modell akármelyik részével, akkor mindegyik háromszöget egyenként meg kell nézni. Ez egy összetettebb épület esetén megtöbbszörözheti a feldolgozási időt. 

Ennek az időnek a lecsökkentésére különböző gyorsító struktúrákat használhatunk. Manapság a leggyakoribb ilyen struktúra a Bounding Volume Hierarchy (BVH).

A BVH lényege, hogy minden háromszöghöz hozzárendelünk egy téglatestet (1. szint), amelybe belefér, majd az egymás mellett lévő téglatesteket párokba helyezzük és azokat is téglatestekbe helyezzük (2. szint). Ezt addig folytatjuk, amíg végül csak egy téglatest marad hátra. 

A sugarak feldolgozásakor először leellenőrizzük, hogy eltalálja-e a külső téglatestet. Ha nem találja el, akkor a háromszögek közül sem találhatta el egyiket se. Ha a téglatestet eltalálta, akkor az abban lévő téglatestekkel is meg kell tennünk ugyan ezt az ellenőrzést. Ennek az előnye, hogy átlagosan az algoritmus komplexitása $O(n)$-ről $O(log(n))$-re csökkent.

\subsection{Rust}
A renderelő rendszer elkészítéséhez Rustot használtunk. Ennek több oka is van:

Mint a szerkesztőnél, itt is fontos szempont volt a gyorsaság, hiszen minél kevesebb önköltsége van a programozási nyelvnek, annál gyorsabbra lehet írni az algoritmusokat.

Ezzel szemben lényeges a biztonság is. A C és a C++ gyors, rendszerközeli nyelvek, de nem érkeznek ugyanazokkal a biztonsági garanciákkal, mint a Rust. Ez nem előnyös egy online renderer esetén, hiszen a felhasználótól kéri az adatokat és olyan környezetben fut ahol el lehet érni bizalmas adatokat. C és C++ esetén bizonyos programhibákkal egy támadó képes lehet átvenni az irányítást a szerver felett és más felhasználók adatait ellopni.

Fontos még kiemelni a Rust generikus rendszerét, amely elősegíti a fent említett komponensek különvételét és egybeágyazását különféle compile idejű optimalizációkkal.

\subsection{Pathtracer}
A raytracerek segítségével lehet a fény viselkedését is szimulálni. Ezt hívjuk Path Trace-nek.

Lényege, hogy a kamerából kijövő sugaraknak hagyjuk, hogy a felületre érkezve folytassák utukat egy másik irányba. Ez az irány a felület tulajdonságaitól függ. Egy tükör a sugarat csak egy irányba küldheti tovább, míg egy téglafal a fényt szórja, tehát több lehetséges iránya is van a fénynek. 

A helyes megjelenítéshez a lehetséges irányok terén kell integrálni az egyes irányokhoz tartozó értékeket, az adott irány szerint súlyozva. Ez egy olyan integrálási probléma, amelynek nincs tényleges megoldása, csak megközelíteni tudjuk.

Erre a megközelítésre létezik a Monte Carlo integrálás. Lényege, hogy a lehetséges irányok közül egy megadott darabot (sample szám) kiválasztunk véletlenszerűen, majd azokat átlagoljuk.

Az így keletkezett kép a várt képnek csak egy megközelítése. Minősége a sample számtól függ. Alacsony sample szám esetén a kép zajos lehet, magas sample szám esetén a feldolgozás ideje megnőhet.

\subsubsection{Open Image Denoise}
Hogy alacsony sample szám esetén is viszonylag jó minőségű képeket kapjunk, az Intel által fejlesztett Open Image Denoise nevű szoftvert használjuk. 

Ez a szoftver mesterséges intelligenciát használ a képen lévő zaj eltávolítására.

Csak x86 alapú rendszereken elérhető.

\todo[inline]{Példa}

\subsection{Elosztott renderelő}

A képek elkészítési idejének csökkentésére a renderelőhöz hozzáadtunk egy elosztási rendszert.

Ez a rendszer RabbitMQ-ra és Redis-re épül. A RabbitMQ egy üzenetküldő rendszer, amely a különböző rétegek közti kommunikációt segíti elő, míg a Redis egy kulcs-érték adatbázis, a hosszabb ideig szükséges és nagyobb adatok tárolására.

A Redis szerverhez hozzáadtuk a RedisAI kiegészítőt, amivel lehet tömbökön végrehajtani matematikai operációkat. Ez a későbbiekben még hasznos lesz.

Az egyszerűbb kezelés érdekében, két különböző réteget hoztunk létre: a tartomány kezelő réteg (domain manager) és a feliratkozó réteg (subscriber)

\subsubsection{Tartománykezelő réteg}
A Tartománykezelő réteg feladata a renderelési kérések fogadása a backendtől, munkákra osztása és a összerakása.

A renderelés elkezdéséhez egy véletlenszerű azonosítót kell generálnunk a kérésünk számára (ID) és Redis-ben a következő értékeket kell beállítanunk:

\begin{itemize}
    \item archyrt:ID:width
    
    A várt kép szélessége pixelben
    \item archyrt:ID:height
    
    A várt kép magassága pixelben
    \item archyrt:ID:samples
    
    A renderelés során használt sample-ök száma
    \item archyrt:ID:scene
    
    A projekt által haszált .ASCN bináris fájl
\end{itemize}

A kéréseket a RabbitMQ \emph{archyrt:dispatch} sorából várja. Az innen beérkező üzenetek karakterláncok, amelynek formátuma:\emph{kérésID\#felhasználóID\#projektID}.

Ekkor a tartománykezelő a képet felosztja 16 egyenlő részre (csempe), és minden rész minden egyes samplejéhez egy-egy munkát köt a saját egyedi azonosítójával. A munkákat a \emph{archyrt:taskqueue} sorba küldi, a következő formátummal:\linebreak\emph{kérésID\#munkaID\#visszatérésiSorNeve\#csempeXKoordinátája\#csempeYKoordinátája}.

A fenti üzenetben megadott sorból egyenként elfogadja az üzeneteket, az üzenetből kiolvassa, hogy a munka során generált kép hova lett mentve, és feldolgozza azt.\linebreak \emph{RedisKulcsAholAKépVan\#CsempeX\#CsempeY}

Ezek után a tartománykezelő végrehajtja a zajeltávolítást és elmenti a képet a fájlrendszerre.

\subsubsection{Feliratkozó réteg}
A feliratkozó réteg feladata a Tartománykezelő által kiadott munkák végrehajtása. 

Miután megkapta a feladatot az \emph{archyrt:taskqueue} sorból (lásd fent), betölti a Redis-ből a kéréshez tartozó jelenetet és kirendereli. Renderelés után feltölti Redis adatbázisba tensorként, véletlenszerű kulccsal és ezt jelzi a tartománykezelőnek.